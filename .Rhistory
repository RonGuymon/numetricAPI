transformations_body,
sep = ",") %>%
gsub('"deleteMe",|"deleteMe"|,"deleteMe"', '', .) %>%
paste0('{', ., '}')
metadata
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
"Content-Type" = "application/json"),
body = metadata,
verbose()
)
numetricName <- "Signbase3"
if(class(dataframeName) == "character"){
fieldAttributesReady_body <- '"deleteMe"'
}else {
## Create a dataframe with column attributes----
# Create a dataframe with columns for each field: field, displayName, autocomplete, and type.
fieldAttributes <- data.frame(field = colnames(dataframeName), # Gets the column names of the dataset to index
displayName = colnames(dataframeName), # Uses the column names of the dataset as the display names
# autocomplete = rep("false", ncol(dataframeName)), # Does not make anything autocompletable
type = array(lapply(dataframeName, class)) %>% as.character() # Gets the class of each column in the dataframe
)
# Convert r class types to valid numetric class types
fieldAttributes <- mutate(fieldAttributes, type = ifelse(type == "character", "string",
ifelse(type == "numeric", "double",
ifelse(type == "integer", "integer",
ifelse(type == "Date" | type == "POSIXct" | type == "POSIXlt", "datetime", "string")))))
# Add in the fields that should be autocompleted and geocoded
fieldAttributes <- mutate(fieldAttributes,
type = ifelse(field %in% geoshapes, "geo_shape",
ifelse(field %in% geopoints, "geo_point", type)),
type = ifelse(grepl("date", field, ignore.case = T), "datetime", type),
type = ifelse(field %in% boolean, "boolean", type)
)
wholeString <- ""
for (i in 1:nrow(fieldAttributes)){
tempString <- paste0('"',fieldAttributes[i,1],'": {"displayName": "',fieldAttributes[i,2] ,'","type": "',fieldAttributes[i,3],'"},')
wholeString <- paste0(wholeString,tempString)
if(i == nrow(fieldAttributes)){
wholeString <- gsub(",$","",wholeString)
}
}
fieldAttributesReady_body <- paste0('"fields": {',wholeString,'}')
}
if(numetricName == "absent__default"){
numetricName_body <- '"deleteMe"'
}else{
numetricName_body <- paste0('"name": "', numetricName, '"')
}
if(primaryKey == "absent__default"){
primaryKey_body <- '"deleteMe"'
}else{
primaryKey_body <- paste0('"primaryKey": ["', primaryKey, '"]')
}
if(category == "absent__default"){
category_body <- '"deleteMe"'
}else{
category_body <- paste0('"categories": ["', category, '"]')
}
if(description == "absent__default"){
description_body <- '"deleteMe"'
}else{
description_body <- paste0('"description": "', description, '"')
}
if(class(transformations) == "character"){
transformations_body <- '"deleteMe"'
}else{
transformations_body <- paste0('"transformations":', toJSON(transformations))
}
metadata <- paste(numetricName_body,
primaryKey_body,
category_body,
description_body,
fieldAttributesReady_body,
transformations_body,
sep = ",") %>%
gsub('"deleteMe",|"deleteMe"|,"deleteMe"', '', .) %>%
paste0('{', ., '}')
metadata
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
"Content-Type" = "application/json"),
body = metadata,
verbose()
)
apiKey
category = "absent__default"
if(class(dataframeName) == "character"){
fieldAttributesReady_body <- '"deleteMe"'
}else {
## Create a dataframe with column attributes----
# Create a dataframe with columns for each field: field, displayName, autocomplete, and type.
fieldAttributes <- data.frame(field = colnames(dataframeName), # Gets the column names of the dataset to index
displayName = colnames(dataframeName), # Uses the column names of the dataset as the display names
# autocomplete = rep("false", ncol(dataframeName)), # Does not make anything autocompletable
type = array(lapply(dataframeName, class)) %>% as.character() # Gets the class of each column in the dataframe
)
# Convert r class types to valid numetric class types
fieldAttributes <- mutate(fieldAttributes, type = ifelse(type == "character", "string",
ifelse(type == "numeric", "double",
ifelse(type == "integer", "integer",
ifelse(type == "Date" | type == "POSIXct" | type == "POSIXlt", "datetime", "string")))))
# Add in the fields that should be autocompleted and geocoded
fieldAttributes <- mutate(fieldAttributes,
type = ifelse(field %in% geoshapes, "geo_shape",
ifelse(field %in% geopoints, "geo_point", type)),
type = ifelse(grepl("date", field, ignore.case = T), "datetime", type),
type = ifelse(field %in% boolean, "boolean", type)
)
wholeString <- ""
for (i in 1:nrow(fieldAttributes)){
tempString <- paste0('"',fieldAttributes[i,1],'": {"displayName": "',fieldAttributes[i,2] ,'","type": "',fieldAttributes[i,3],'"},')
wholeString <- paste0(wholeString,tempString)
if(i == nrow(fieldAttributes)){
wholeString <- gsub(",$","",wholeString)
}
}
fieldAttributesReady_body <- paste0('"fields": {',wholeString,'}')
}
if(numetricName == "absent__default"){
numetricName_body <- '"deleteMe"'
}else{
numetricName_body <- paste0('"name": "', numetricName, '"')
}
if(primaryKey == "absent__default"){
primaryKey_body <- '"deleteMe"'
}else{
primaryKey_body <- paste0('"primaryKey": ["', primaryKey, '"]')
}
if(category == "absent__default"){
category_body <- '"deleteMe"'
}else{
category_body <- paste0('"categories": ["', category, '"]')
}
if(description == "absent__default"){
description_body <- '"deleteMe"'
}else{
description_body <- paste0('"description": "', description, '"')
}
if(class(transformations) == "character"){
transformations_body <- '"deleteMe"'
}else{
transformations_body <- paste0('"transformations":', toJSON(transformations))
}
metadata <- paste(numetricName_body,
primaryKey_body,
category_body,
description_body,
fieldAttributesReady_body,
transformations_body,
sep = ",") %>%
gsub('"deleteMe",|"deleteMe"|,"deleteMe"', '', .) %>%
paste0('{', ., '}')
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
"Content-Type" = "application/json"),
body = metadata,
verbose()
)
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
"Content-Type" = "application/json"),
body = metadata,
verbose()
)
r <- GET(paste0("https://api.numetric.com/v3/table/", tableId1),
add_headers("Authorization" = apiKey,
"Content-Type" = "application/json"),
verbose()
)
response <- httr::content(r, as = "text") %>% fromJSON()
response
trannies <- response$transformations
transformations <- trannies %>%
mutate(
sourceField = "L2DirOfTravel",
targetField = "L2DirOfTravel",
index = ifelse(index == 1, 3, 4)
) %>%
bind_rows(trannies, .) %>%
.[1:4,]
transformations <- trannies %>%
mutate(
sourceField = "L2DirOfTravel",
targetField = "L2DirOfTravel",
index = ifelse(index == 1, 3, 4)
) %>%
bind_rows(trannies, .) %>%
.[1:2,]
View(transformations)
if(class(dataframeName) == "character"){
fieldAttributesReady_body <- '"deleteMe"'
}else {
## Create a dataframe with column attributes----
# Create a dataframe with columns for each field: field, displayName, autocomplete, and type.
fieldAttributes <- data.frame(field = colnames(dataframeName), # Gets the column names of the dataset to index
displayName = colnames(dataframeName), # Uses the column names of the dataset as the display names
# autocomplete = rep("false", ncol(dataframeName)), # Does not make anything autocompletable
type = array(lapply(dataframeName, class)) %>% as.character() # Gets the class of each column in the dataframe
)
# Convert r class types to valid numetric class types
fieldAttributes <- mutate(fieldAttributes, type = ifelse(type == "character", "string",
ifelse(type == "numeric", "double",
ifelse(type == "integer", "integer",
ifelse(type == "Date" | type == "POSIXct" | type == "POSIXlt", "datetime", "string")))))
# Add in the fields that should be autocompleted and geocoded
fieldAttributes <- mutate(fieldAttributes,
type = ifelse(field %in% geoshapes, "geo_shape",
ifelse(field %in% geopoints, "geo_point", type)),
type = ifelse(grepl("date", field, ignore.case = T), "datetime", type),
type = ifelse(field %in% boolean, "boolean", type)
)
wholeString <- ""
for (i in 1:nrow(fieldAttributes)){
tempString <- paste0('"',fieldAttributes[i,1],'": {"displayName": "',fieldAttributes[i,2] ,'","type": "',fieldAttributes[i,3],'"},')
wholeString <- paste0(wholeString,tempString)
if(i == nrow(fieldAttributes)){
wholeString <- gsub(",$","",wholeString)
}
}
fieldAttributesReady_body <- paste0('"fields": {',wholeString,'}')
}
if(numetricName == "absent__default"){
numetricName_body <- '"deleteMe"'
}else{
numetricName_body <- paste0('"name": "', numetricName, '"')
}
if(primaryKey == "absent__default"){
primaryKey_body <- '"deleteMe"'
}else{
primaryKey_body <- paste0('"primaryKey": ["', primaryKey, '"]')
}
if(category == "absent__default"){
category_body <- '"deleteMe"'
}else{
category_body <- paste0('"categories": ["', category, '"]')
}
if(description == "absent__default"){
description_body <- '"deleteMe"'
}else{
description_body <- paste0('"description": "', description, '"')
}
if(class(transformations) == "character"){
transformations_body <- '"deleteMe"'
}else{
transformations_body <- paste0('"transformations":', toJSON(transformations))
}
metadata <- paste(numetricName_body,
primaryKey_body,
category_body,
description_body,
fieldAttributesReady_body,
transformations_body,
sep = ",") %>%
gsub('"deleteMe",|"deleteMe"|,"deleteMe"', '', .) %>%
paste0('{', ., '}')
metadata
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
`Content-Type` = "application/json"),
body = metadata,
verbose()
)
numetricName <- "Signbase2"
if(class(dataframeName) == "character"){
fieldAttributesReady_body <- '"deleteMe"'
}else {
## Create a dataframe with column attributes----
# Create a dataframe with columns for each field: field, displayName, autocomplete, and type.
fieldAttributes <- data.frame(field = colnames(dataframeName), # Gets the column names of the dataset to index
displayName = colnames(dataframeName), # Uses the column names of the dataset as the display names
# autocomplete = rep("false", ncol(dataframeName)), # Does not make anything autocompletable
type = array(lapply(dataframeName, class)) %>% as.character() # Gets the class of each column in the dataframe
)
# Convert r class types to valid numetric class types
fieldAttributes <- mutate(fieldAttributes, type = ifelse(type == "character", "string",
ifelse(type == "numeric", "double",
ifelse(type == "integer", "integer",
ifelse(type == "Date" | type == "POSIXct" | type == "POSIXlt", "datetime", "string")))))
# Add in the fields that should be autocompleted and geocoded
fieldAttributes <- mutate(fieldAttributes,
type = ifelse(field %in% geoshapes, "geo_shape",
ifelse(field %in% geopoints, "geo_point", type)),
type = ifelse(grepl("date", field, ignore.case = T), "datetime", type),
type = ifelse(field %in% boolean, "boolean", type)
)
wholeString <- ""
for (i in 1:nrow(fieldAttributes)){
tempString <- paste0('"',fieldAttributes[i,1],'": {"displayName": "',fieldAttributes[i,2] ,'","type": "',fieldAttributes[i,3],'"},')
wholeString <- paste0(wholeString,tempString)
if(i == nrow(fieldAttributes)){
wholeString <- gsub(",$","",wholeString)
}
}
fieldAttributesReady_body <- paste0('"fields": {',wholeString,'}')
}
if(numetricName == "absent__default"){
numetricName_body <- '"deleteMe"'
}else{
numetricName_body <- paste0('"name": "', numetricName, '"')
}
if(primaryKey == "absent__default"){
primaryKey_body <- '"deleteMe"'
}else{
primaryKey_body <- paste0('"primaryKey": ["', primaryKey, '"]')
}
if(category == "absent__default"){
category_body <- '"deleteMe"'
}else{
category_body <- paste0('"categories": ["', category, '"]')
}
if(description == "absent__default"){
description_body <- '"deleteMe"'
}else{
description_body <- paste0('"description": "', description, '"')
}
if(class(transformations) == "character"){
transformations_body <- '"deleteMe"'
}else{
transformations_body <- paste0('"transformations":', toJSON(transformations))
}
metadata <- paste(numetricName_body,
primaryKey_body,
category_body,
description_body,
fieldAttributesReady_body,
transformations_body,
sep = ",") %>%
gsub('"deleteMe",|"deleteMe"|,"deleteMe"', '', .) %>%
paste0('{', ., '}')
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
`Content-Type` = "application/json"),
body = metadata,
verbose()
)
r <- GET(paste0("https://api.numetric.com/v3/table/", tableId1),
add_headers("Authorization" = apiKey,
"Content-Type" = "application/json"),
verbose()
)
response <- httr::content(r, as = "text") %>% fromJSON()
response
trannies <- response$transformations
transformations <- trannies %>%
mutate(
sourceField = "L2DirOfTravel",
targetField = "L2DirOfTravel",
index = ifelse(index == 1, 3, 4)
) %>%
bind_rows(trannies, .) %>%
.[1:4,]
View(trannies)
numetricName <- "Signbase2"
category <- "Linguini"
if(class(dataframeName) == "character"){
fieldAttributesReady_body <- '"deleteMe"'
}else {
## Create a dataframe with column attributes----
# Create a dataframe with columns for each field: field, displayName, autocomplete, and type.
fieldAttributes <- data.frame(field = colnames(dataframeName), # Gets the column names of the dataset to index
displayName = colnames(dataframeName), # Uses the column names of the dataset as the display names
# autocomplete = rep("false", ncol(dataframeName)), # Does not make anything autocompletable
type = array(lapply(dataframeName, class)) %>% as.character() # Gets the class of each column in the dataframe
)
# Convert r class types to valid numetric class types
fieldAttributes <- mutate(fieldAttributes, type = ifelse(type == "character", "string",
ifelse(type == "numeric", "double",
ifelse(type == "integer", "integer",
ifelse(type == "Date" | type == "POSIXct" | type == "POSIXlt", "datetime", "string")))))
# Add in the fields that should be autocompleted and geocoded
fieldAttributes <- mutate(fieldAttributes,
type = ifelse(field %in% geoshapes, "geo_shape",
ifelse(field %in% geopoints, "geo_point", type)),
type = ifelse(grepl("date", field, ignore.case = T), "datetime", type),
type = ifelse(field %in% boolean, "boolean", type)
)
wholeString <- ""
for (i in 1:nrow(fieldAttributes)){
tempString <- paste0('"',fieldAttributes[i,1],'": {"displayName": "',fieldAttributes[i,2] ,'","type": "',fieldAttributes[i,3],'"},')
wholeString <- paste0(wholeString,tempString)
if(i == nrow(fieldAttributes)){
wholeString <- gsub(",$","",wholeString)
}
}
fieldAttributesReady_body <- paste0('"fields": {',wholeString,'}')
}
if(numetricName == "absent__default"){
numetricName_body <- '"deleteMe"'
}else{
numetricName_body <- paste0('"name": "', numetricName, '"')
}
if(primaryKey == "absent__default"){
primaryKey_body <- '"deleteMe"'
}else{
primaryKey_body <- paste0('"primaryKey": ["', primaryKey, '"]')
}
if(category == "absent__default"){
category_body <- '"deleteMe"'
}else{
category_body <- paste0('"categories": ["', category, '"]')
}
if(description == "absent__default"){
description_body <- '"deleteMe"'
}else{
description_body <- paste0('"description": "', description, '"')
}
if(class(transformations) == "character"){
transformations_body <- '"deleteMe"'
}else{
transformations_body <- paste0('"transformations":', toJSON(transformations))
}
metadata <- paste(numetricName_body,
primaryKey_body,
category_body,
description_body,
fieldAttributesReady_body,
transformations_body,
sep = ",") %>%
gsub('"deleteMe",|"deleteMe"|,"deleteMe"', '', .) %>%
paste0('{', ., '}')
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
`Content-Type` = "application/json"),
body = metadata,
verbose()
)
transformations <- trannies %>%
mutate(
sourceField = "L2DirOfTravel",
targetField = "L2DirOfTravel",
index = ifelse(index == 1, 3, 4)
) %>%
bind_rows(trannies, .) %>%
.[1:1,]
numetricName <- "Signbase2"
category <- "Linguini"
numetricName <- "Signbase3"
category <- "Linguini2"
if(class(dataframeName) == "character"){
fieldAttributesReady_body <- '"deleteMe"'
}else {
## Create a dataframe with column attributes----
# Create a dataframe with columns for each field: field, displayName, autocomplete, and type.
fieldAttributes <- data.frame(field = colnames(dataframeName), # Gets the column names of the dataset to index
displayName = colnames(dataframeName), # Uses the column names of the dataset as the display names
# autocomplete = rep("false", ncol(dataframeName)), # Does not make anything autocompletable
type = array(lapply(dataframeName, class)) %>% as.character() # Gets the class of each column in the dataframe
)
# Convert r class types to valid numetric class types
fieldAttributes <- mutate(fieldAttributes, type = ifelse(type == "character", "string",
ifelse(type == "numeric", "double",
ifelse(type == "integer", "integer",
ifelse(type == "Date" | type == "POSIXct" | type == "POSIXlt", "datetime", "string")))))
# Add in the fields that should be autocompleted and geocoded
fieldAttributes <- mutate(fieldAttributes,
type = ifelse(field %in% geoshapes, "geo_shape",
ifelse(field %in% geopoints, "geo_point", type)),
type = ifelse(grepl("date", field, ignore.case = T), "datetime", type),
type = ifelse(field %in% boolean, "boolean", type)
)
wholeString <- ""
for (i in 1:nrow(fieldAttributes)){
tempString <- paste0('"',fieldAttributes[i,1],'": {"displayName": "',fieldAttributes[i,2] ,'","type": "',fieldAttributes[i,3],'"},')
wholeString <- paste0(wholeString,tempString)
if(i == nrow(fieldAttributes)){
wholeString <- gsub(",$","",wholeString)
}
}
fieldAttributesReady_body <- paste0('"fields": {',wholeString,'}')
}
if(numetricName == "absent__default"){
numetricName_body <- '"deleteMe"'
}else{
numetricName_body <- paste0('"name": "', numetricName, '"')
}
if(primaryKey == "absent__default"){
primaryKey_body <- '"deleteMe"'
}else{
primaryKey_body <- paste0('"primaryKey": ["', primaryKey, '"]')
}
if(category == "absent__default"){
category_body <- '"deleteMe"'
}else{
category_body <- paste0('"categories": ["', category, '"]')
}
if(description == "absent__default"){
description_body <- '"deleteMe"'
}else{
description_body <- paste0('"description": "', description, '"')
}
if(class(transformations) == "character"){
transformations_body <- '"deleteMe"'
}else{
transformations_body <- paste0('"transformations":', toJSON(transformations))
}
metadata <- paste(numetricName_body,
primaryKey_body,
category_body,
description_body,
fieldAttributesReady_body,
transformations_body,
sep = ",") %>%
gsub('"deleteMe",|"deleteMe"|,"deleteMe"', '', .) %>%
paste0('{', ., '}')
r <- PATCH(paste0("https://api.numetric.com/v3/table/", tableId),
add_headers("Authorization" = apiKey,
`Content-Type` = "application/json"),
body = metadata,
verbose()
)
rm(transformations)
